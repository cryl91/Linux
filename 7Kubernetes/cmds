--commands = 
1.Creating eks cluster = eksctl create cluster --config-file=eks.yaml
2.Deleting eks cluster = eksctl delete cluster --name eks-cluster
3.Create Cluster CLI = eksctl create/delete cluster --name hub-cluster --region us-west-1 --nodes 4 --node-type t3.medium // By default, eksctl creates a single node group with 2 EC2 worker nodes of t3.medium and 20gb disk space
3.To see all clusters = kubectl config get-contexts++++ To use one cluster = kubectl config use-contexts cluster-name
--kubectl config = It’s the command to view or modify your Kubernetes kubeconfig file (usually ~/.kube/config). That file stores connection info for one or more clusters
--Contexts → Named combinations of cluster + user + namespace.

4.Create = kubectl create -f namespace.yaml or kubectl create namespace namespace.yaml
5.apply(update when resource exists) = kubectl apply -f namespace.yaml 
6.delete = kubectl delete -f namespace.yaml

7.Get pods within namespace = kubectl get pods -n roboshop or kubectl get pods --all-namespaces
8.To edit = Kubectl edit svc <service-name>
9.Run = Kubectl run nginx --image=nginx --replicas=2
10.Enter pod = kubectl exec -it nginx -- bash
11.Enter pod of a particular container = kubectl exec -it multicontainer -c sidecar -n roboshop -- bash
12.To enter into a namespace = Kubens roboshop
13.To delete pod = kubectl delete pod <pod-name> 
14. Scale = kubectl scale replicaset <replicaset name> --replicas=2
15. kubectl create deployment nginx --image=nginx --replicas=2

14.Password Encode =  echo "H1" | base64
15.Password Decode =  echo "SDEK" | base64 --decode

15.alias ka "kubectl apply -f manifest.yaml" -> from next time just type ka to apply
16.Install EBS Drivers = kubectl apply -k "github.com/kubernetes-sigs/aws-ebs-csi-driver/deploy/kubernetes/overlays/stable/?ref=release-1.7"
17. Create EKS Cluster = 
  1. eksctl create cluster --name=observability \
                      --region=us-east-1 \
                      --zones=us-east-1a,us-east-1b \
                      --without-nodegroup
  2. This OIDC Provider allows pods to communicate with other resources of AWS ie This binds IAM with service accounts of kubernetes    
  eksctl utils associate-iam-oidc-provider \ 
    --region us-east-1 \
    --cluster observability \
    --approve
  3. eksctl create nodegroup --cluster=observability \
                        --region=us-east-1 \
                        --name=observability-ng-private \
                        --node-type=t3.medium \
                        --nodes-min=2 \
                        --nodes-max=3 \
                        --node-volume-size=20 \
                        --managed \
                        --asg-access \
                        --external-dns-access \
                        --full-ecr-access \
                        --appmesh-access \
                        --alb-ingress-access \
                        --node-private-networking

  4. aws eks update-kubeconfig --name observability = # Update ./kube/config file

--Pods are the smallest deployable units in Kubernetes, but they’re not meant to be scaled directly. Instead, you should scale a Deployment, ReplicaSet, or StatefulSet—these manage Pods and support scaling. Ex = kubectl scale deployment nginx --replicas=2

--Add the AWS EBS CSI Helm repo: Install with Helm
1. helm repo add aws-ebs-csi-driver https://kubernetes-sigs.github.io/aws-ebs-csi-driver
   helm repo update
2. helm upgrade --install aws-ebs-csi-driver \
                  aws-ebs-csi-driver/aws-ebs-csi-driver \
                  --namespace kube-system \
                  --set enableVolumeScheduling=true \   
                  --set enableVolumeResizing=true \
                  --set enableVolumeSnapshot=true
3. After installation, check that the CSI pods are running:
   kubectl get pods -n kube-system | grep ebs

--Helm = 
1. helm install <name of chart> . ++++ nginx — This is the release name. It's the name you are giving to this particular deployment of the Helm chart
2. To delete = helm delete <name>
3. To update = helm upgrade <name> .
4. To see history = helm history <name>
4. To Revert to Previous version = helm rollback <name>

--To install apache benchmark = 
1. Install it = sudo yum install -y httpd-tools
2. check it using = ab -V
3. How to use it = ab -n 10000 -c 100 https://www.google.com/

--eks cluster creation config file = 
apiVersion: eksctl.io/v1alpha5
kind: ClusterConfig

metadata:
  name: hub-cluster
  region: us-west-1

nodeGroups:
  - name: ng-1
    instanceType: t3.medium
    desiredCapacity: 2
    minSize: 1
    maxSize: 3
    volumeSize: 20
    ssh:
      allow: true


--Promethus Install Info
1. Install Prometheus
2. Expose prometheus as nodeport =  kubectl expose service prometheus-server --type=NodePort --target-port=9090 --name=prometheus-server-ext
 or  kubectl expose service prometheus-kube-prometheus-prometheus \
  --type=NodePort \
  --target-port=9090 \
  --name=prometheus-server-ext

--Grafana Install = 
1. Install Grafana
2. Expose Grafana as nodeport =  kubectl expose service my-grafana --type=NodePort --target-port=3000 --name=my-grafana-ext
3. Add Promethus in grafana -> Import Dashboard/Standard Template = 3662
4. To get more info expose kube-metrics = kubectl expose service prometheus-kube-state-metrics --type=NodePort --target-port=8080 --name=prometheus-kubemetrics

--Installing Argocd = svc+secret+Password decode
1. https://argo-cd.readthedocs.io/en/stable/getting_started/ 
2. kubectl edit svc argocd-server -n argocd = Change cluster IP -> nodeport 
3. Kubectl edit secret argocd-initial-admin-secret -n argocd = Get the password to login (Username is defaut "admin")
4. Password needs to be decoded =  echo "T1R0ZGo2dnhKWGFxeWN0bg==" | base64 --decode
5. Login in the browser using = Node IP:Nodeport number
6. In the argocd website = Create application -> app name in smallcase, project name(default), sync policy(automatic), source url(github repo), path(github path), destination/cluster url(choose default like https:kuberenets.default.svc), namespace(default) -> click create button

--Benefits of argocd = 
1. Self-Healing = If someone makes a manual change in the cluster (kubectl edit/apply), ArgoCD can auto-revert it back to the Git-defined state.
2. Easy Rollbacks = Since Git keeps your history, rolling back = checking out an old commit and syncing.
3. 
4. So Argo CD = GitOps + Kubernetes deployments made easy, safe, and auditable.